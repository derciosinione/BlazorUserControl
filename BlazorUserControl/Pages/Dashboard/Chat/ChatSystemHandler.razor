@using Application
@using Application.Modules.R2Y.Repositories.Interface.Chat
@using Application.Modules.R2Y.Repositories.Interface.Users
@using Application.Provider
@using FluentResults
@using StrawberryShake
@implements IDisposable
@implements IObserver<IOperationResult<IOnMessageReceivedResult>>

@code {
    [Inject] public IUserService UserService { get; set; } = default!;
    [Inject] public IChatService ChatService { get; set; } = default!;
    [Inject] public AppAuthStateProvider AuthStateProvider { get; set; } = default!;

    // Data Sources
    public IReadOnlyList<IGetAllUsers_AllUsers>? AllUsers { get; set; } = new List<IGetAllUsers_AllUsers>();
    public IReadOnlyList<IGetAllUserRoom_AllChatRoomByUserEmail>? AllChats { get; set; } = new
    List<IGetAllUserRoom_AllChatRoomByUserEmail>();
    public List<IGetChatMessages_AllMessagesByChatRoomId> Messages { get; set; } = new();

    private IDisposable? _messageSubscription;

    // State
    public bool IsLoadingUsers { get; set; } = false;
    public bool IsLoadingChats { get; set; } = false;
    public bool IsLoadingMessages { get; set; } = false;
    public string CurrentUserEmail { get; set; } = "";

    protected override async Task OnInitializedAsync()
    {
        var userInfo = await AuthStateProvider.GetUserInfo();
        if (userInfo != null)
        {
            CurrentUserEmail = userInfo.Email;
            await LoadChats();

            // Subscribe to real-time messages
            _messageSubscription = ChatService.SubscribeToMessages(CurrentUserEmail)
            .Subscribe(this);
        }
    }

    private void HandleIncomingMessage(IOnMessageReceived_OnMessageReceived msg)
    {
        // 1. If chat is selected and matches room, append message
        // Unfortunately the subscription type is different from the query type, so we might need mapping or dynamic usage
        // But for display purposed in the list, usually they share fields.

        // Let's create an adapter object or check if we can cast/use common props.
        // For simplicity, we just trigger reload if it's the current room, OR we manually add it if we can

        // Actually, let's try to map it to IGetChatMessages_AllMessagesByChatRoomId if possible, or use a local View Model.
        // Since we are using generated interfaces directly, we can't easily cast them.

        // STRATEGY:
        // If the message belongs to the current open chat, we reload the messages to be safe and consistent
        // OR we just assume it's valid and add it. To avoid type incompatibility issues given the time constraints,
        // and since the user just wants the interface updated:

        // Check if the message belongs to the current open chat
        // We'll rely on the UI binding. Since we used `IEnumerable` initially, we should change `Messages` to `List` (done
        // above) to allow adding.

        // Note: The types IOnMessageReceived_OnMessageReceived and IGetChatMessages_AllMessagesByChatRoomId are generated
        // interfaces.
        // We cannot add one to a list of the other.
        // FIX: We will just reload the messages if the chat matches. This is safer.
        // Also we should reload the chat list to update "Last Message" preview once we implement that properly.

        InvokeAsync(async () =>
        {
            Console.WriteLine($"[Handler] Received msg for room {msg.ChatRoomId}");
            await LoadChats(); // Always safe to update sidebar
            await OnNewMessageReceived(msg);
            StateHasChanged();
        });
    }

    // Allow child to hook into this
    protected virtual Task OnNewMessageReceived(IOnMessageReceived_OnMessageReceived msg)
    {
        return Task.CompletedTask;
    }

    protected async Task LoadAllUsers()
    {
        if (AllUsers!.Any()) return;

        IsLoadingUsers = true;
        StateHasChanged();

        var result = await UserService.GetAllUsers();
        if (result is { IsSuccess: true, Value: not null })
        {
            AllUsers = result.Value;
        }

        IsLoadingUsers = false;
        StateHasChanged();
    }

    private async Task LoadChats()
    {
        IsLoadingChats = true;
        StateHasChanged();

        var result = await ChatService.GetAllUserRoom(CurrentUserEmail);
        if (result is { IsSuccess: true, Value: not null })
        {
            AllChats = result.Value;
        }

        IsLoadingChats = false;
        StateHasChanged();
    }

    protected async Task LoadMessages(Guid roomId)
    {
        IsLoadingMessages = true;
        StateHasChanged();

        var result = await ChatService.GetMessagesAsync(roomId);

        Messages = result.IsSuccess ? result.Value.OrderBy(m => m.SentAt).ToList() : new
        List<IGetChatMessages_AllMessagesByChatRoomId>();

        IsLoadingMessages = false;
        StateHasChanged();
    }

    protected async Task SendMessage(Guid roomId, string content)
    {
        if (string.IsNullOrWhiteSpace(content)) return;

        var result = await ChatService.SendMessageAsync(roomId, CurrentUserEmail, content);

        if (result.IsSuccess)
        {
            await LoadMessages(roomId);
        }
    }

    protected async Task DeleteMessage(Guid messageId)
    {
        // For security, checking if SelectedChat is available in child or just passing ID.
        // But here we might not know the roomId if not passed.
        // We will optimistically remove from UI first or reload.
        // Actually, we need RoomId for the API call.

        // Wait, the API requires ChatRoomId.
        // We'll overload or assume the child passes it.
    }

    protected async Task DeleteMessage(Guid roomId, Guid messageId)
    {
        var result = await ChatService.DeleteMessageAsync(roomId, messageId, CurrentUserEmail);

        if (result.IsSuccess && result.Value)
        {
            // Remove from local list if present
            var msg = Messages.FirstOrDefault(m => m.Id == messageId);
            if (msg != null)
            {
                Messages.Remove(msg);
                StateHasChanged();
            }
        }
    }

    protected async Task<Guid?> CreatePrivateChat(string targetUserEmail)
    {
        var result = await ChatService.CreatePrivateRoomAsync(targetUserEmail, CurrentUserEmail);

        if (!result.IsSuccess) return null;

        await LoadChats();
        return result.Value.Data?.Id;
    }

    public void Dispose()
    {
        _messageSubscription?.Dispose();
    }

    public void OnCompleted()
    {
    }

    public void OnError(Exception error)
    {
    }

    public void OnNext(IOperationResult<IOnMessageReceivedResult> result)
    {
        if (result.Data != null)
        {
            var msg = result.Data.OnMessageReceived;
            HandleIncomingMessage(msg);
        }
    }
}